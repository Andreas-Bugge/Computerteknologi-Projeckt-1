#!/usr/bin/env python
#################################################################################
# Copyright 2018 ROBOTIS CO., LTD.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#################################################################################

# Authors: Gilbert #
# Authors: Andreas Bugge & Mathies Schou #

import rospy
import math
from sensor_msgs.msg import LaserScan
from geometry_msgs.msg import Twist

# Global Variables
LINEAR_VEL = 0.22
STOP_DISTANCE = 0.1
LIDAR_ERROR = 0.05
SAFE_STOP_DISTANCE = STOP_DISTANCE + LIDAR_ERROR
TURNING_DISTANCE = 0.5

# Turning factor: Left = 1, Right = -1
TURN_FACTOR = ([1, -1])


# Class for obstacle dection.
class Obstacle():

    # Setting up interactions with the ROS-system.
    def __init__(self):
        self._cmd_pub = rospy.Publisher('cmd_vel', Twist, queue_size=1)
        self.obstacle()

    # Function for setting up a scan filter array that gets us information from the lidar.  
    def get_scan(self):
        scan = rospy.wait_for_message('scan', LaserScan)
        scan_filter = []
       
        scan_filter = list(scan.ranges[0:359])
        # Sorts out all invalid, NaN and zeros from our scan_filter       
        for i in range(len(scan_filter)):
            if scan_filter[i] == float('Inf'):
                scan_filter[i] = 3.5
            elif math.isnan(scan_filter[i]):
                scan_filter[i] = 3.5
            elif scan_filter[i] == 0:
                scan_filter[i] = 3.5
        
        Left_front_cone = scan_filter[0:10]
        Right_front_cone = scan_filter[350:359]
        Front_cone = Left_front_cone + Right_front_cone
        Front_cone = min(Front_cone)
        Left_cone = min(scan_filter[11:31])
        Right_cone = min(scan_filter[329:349])
        Backing_cone = min(scan_filter[170:190])

        return Front_cone, Left_cone, Right_cone, Backing_cone

    def obstacle(self):
        twist = Twist()
        turtlebot_moving = True

        while not rospy.is_shutdown():
            Front_cone, Left_cone, Right_cone, Backing_cone = self.get_scan()


            # If turtlebot in movement.
            if turtlebot_moving:
                if Front_cone < TURNING_DISTANCE:
                    twist.linear.x = 0.5 * LINEAR_VEL
                    twist.angular.z = TURN_FACTOR[0]
                    self._cmd_pub.publish(twist)
                    rospy.loginfo('Turning left!')
                
                elif Front_cone < SAFE_STOP_DISTANCE:
                    twist.linear.x = -0.5 * LINEAR_VEL
                    twist.angular.z = 0.0
                    self._cmd_pub.publish(twist)
                    rospy.loginfo('Backing up!')

                else:
                    twist.linear.x = LINEAR_VEL
                    twist.angular.z = 0.0
                    self._cmd_pub.publish(twist)
                    turtlebot_moving = True
                    rospy.loginfo('Distance of the obstacle: %f', Front_cone)
            
            # If turtlebot is not moving
            else:
                twist.linear.x = 0.
                twist.angular.z = 0.0
                self._cmd_pub.publish(twist)
                turtlebot_moving = False
                rospy.loginfo('Stop!')

def main():
    rospy.init_node('turtlebot3_obstacle')
    try:
        obstacle = Obstacle()
    except rospy.ROSInterruptException:
        pass

if __name__ == '__main__':
    main()
