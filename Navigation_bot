#!/usr/bin/env python
#################################################################################
# Copyright 2018 ROBOTIS CO., LTD.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#################################################################################

# Authors: Gilbert #
# Authors: Andreas Bugge & Mathies Schou #

# Importing the necessary libraries
import rospy
import math
from sensor_msgs.msg import LaserScan
from geometry_msgs.msg import Twist
import smbus2
import time

# Global Variables
LINEAR_VEL = 0.22
STOP_DISTANCE = 0.2
LIDAR_ERROR = 0.05
SAFE_STOP_DISTANCE = STOP_DISTANCE + LIDAR_ERROR
TURNING_DISTANCE = 0.4

# Class for obstacle dection.
class Obstacle():

    # Setting up interactions with the ROS-system.
    def __init__(self):
        self._cmd_pub = rospy.Publisher('cmd_vel', Twist, queue_size=1)
        self.obstacle()

    # Function for setting up a scan filter array that gets us information from the lidar.  
    def get_scan(self):
        scan = rospy.wait_for_message('scan', LaserScan)
        scan_filter = []
        scan_filter = list(scan.ranges[0:359])
        # Sorts out all invalid, NaN and zeros from our scan_filter       
        for i in range(len(scan_filter)):
            if scan_filter[i] == float('Inf'):
                scan_filter[i] = 20.0
            if math.isnan(scan_filter[i]):
                scan_filter[i] = 20.0
            elif scan_filter[i] == 0:
                scan_filter[i] = 20.0
        
        # Makes the front cones that the turtlebot uses detection indicators
        Left_front_cone = scan_filter[0:15]
        Right_front_cone = scan_filter[345:359]
        Front_cone = Left_front_cone + Right_front_cone
        Front_cone = min(Front_cone)

        Front_Left_cone = min(scan_filter[16:36])
        Front_Right_cone = min(scan_filter[324:344])
        Backing_cone = min(scan_filter[170:190])

        # TEMP: Not used ATM
        Left_cone = min(scan_filter[37:70])
        Right_cone= min(scan_filter[290:323])

        return Front_cone, Front_Left_cone, Front_Right_cone, Backing_cone, Left_cone, Right_cone

    def obstacle(self):

        # Initial stats for the program
        twist = Twist()
        turtlebot_moving = True
        Victims_found = 0
        Collision_counter = 0

        # Speed stats
        Accumulated_speed = 0
        Speed_updates = 0

        # Runtime settings
        Run_time = 60 * 2
        End_run = time.time() + Run_time

        # Rotation settings
        Turn_time = 14
    
        # Turtlebot is moving forward
        def Forward (speed):
            twist.linear.x = speed
            twist.angular.z = 0.0
            self._cmd_pub.publish(twist)
            rospy.loginfo('Moving forward! %f', Front_cone)

        # Turning turtlebot to the right
        def Turn_right (speed,turn):   
            twist.linear.x = speed
            twist.angular.z = -turn
            self._cmd_pub.publish(twist)
            rospy.loginfo('Turning to right! %f', Front_Right_cone)

        # Turning turtlebot to the left
        def Turn_left (speed, turn):
            twist.linear.x = speed
            twist.angular.z = turn
            self._cmd_pub.publish(twist)
            rospy.loginfo('Turning to left! %f', Front_Left_cone)

        # Turtlebot is backing up
        def Backing (speed):   
            twist.linear.x = speed
            twist.angular.z = 0.0
            self._cmd_pub.publish(twist)
            rospy.loginfo('Backing! %f', Backing_cone)

        # Turning around in case of encirclement
        def Turning_around_right (turn):
            twist.linear.x = 0.0
            twist.angular.z = turn
            self._cmd_pub.publish(twist)
            rospy.loginfo('Turning around!') 
        
        # Turning around in case of encirclement
        def Turning_around_left (turn):
            twist.linear.x = 0.0
            twist.angular.z = turn
            self._cmd_pub.publish(twist)
            rospy.loginfo('Turning around!') 

        # Stats function for the program
        def Stats():
            rospy.loginfo('Victims found: %f', Victims_found)
            rospy.loginfo('Collision counter: %f', Collision_counter)
            rospy.loginfo('Accumulated speed: %f', Accumulated_speed)
            rospy.loginfo('Speed updates: %f', Speed_updates)

        # Control loop for the program
        while not rospy.is_shutdown() and time.time() < End_run:
            Front_cone, Front_Left_cone, Front_Right_cone, Backing_cone, Left_cone, Right_cone = self.get_scan()
            
            # If turtlebot is moving forward og turning
            if turtlebot_moving:
                # Resetting the turn time
                Turn_time = 14

                # If there is a wall to close to the turtlebot, it will back up
                if Front_cone < SAFE_STOP_DISTANCE:
                    # Backing up turtlebot for one second
                    Backing(-0.3 * LINEAR_VEL)
                    # Stop the turtlebot
                    turtlebot_moving = False  
                    rospy.loginfo('---1---') 

                # If it is possible to make a SOFT TURN
                if Front_cone < TURNING_DISTANCE:
                    # If there is more space to the right than to the left, turtlebot will turn right.
                    if Front_Left_cone < Front_Right_cone:
                        Turn_right(LINEAR_VEL, 1) 
                        rospy.loginfo('---2---') 
                        # If there is need for at sharp turn to the right
                        if Front_cone < TURNING_DISTANCE / 1.3:
                            Turn_right(0.2 * LINEAR_VEL, 1)
                            rospy.loginfo('---3---')


                        # If there more space to the left than to the right, turtlebot will turn left.
                    elif Front_Left_cone > Front_Right_cone:
                        Turn_left(LINEAR_VEL, 1)
                        rospy.loginfo('---4---')
                        # If there is need for at sharp turn to the left
                        if Front_cone < TURNING_DISTANCE / 1.3:
                            Turn_left(0.2 * LINEAR_VEL, 1)
                        
                # If there is a clear way ahead, turtlebot will move forward.
                else:
                    Forward(LINEAR_VEL)
                    rospy.loginfo('---5---')

                    # If there is consistent faulty scans, turtlebot will back up.
                    if Front_cone > 10.0:
                        Turn_time = 2
                        if (Turn_time > 0):
                            Backing(0.3 * LINEAR_VEL)
                            Turn_time -= 1
                            rospy.loginfo('---6---')
                        else:
                            turtlebot_moving = False
                   
            # If turtlebot is NOT moving
            else:
                # If there is a wall to close to the turtlebot, it will back up
                if Front_cone < SAFE_STOP_DISTANCE and Front_Left_cone < SAFE_STOP_DISTANCE:
                    Backing(-1 * LINEAR_VEL)
                    rospy.loginfo('---7---')
                
                elif Front_cone < SAFE_STOP_DISTANCE and Front_Right_cone < SAFE_STOP_DISTANCE:
                    Backing(-1 * LINEAR_VEL)
                    rospy.loginfo('---8---')

                # If there less then 35 cm, we turn around 
                if Front_cone < SAFE_STOP_DISTANCE * 1.6 :
                    # If turn_time counter is above 0, turtlebot will turn around in a circle
                    if Turn_time > 0:
                        if Front_Left_cone < Front_Right_cone:
                            Turn_factor = 1
                            rospy.loginfo('---9---')
                        else:
                            Turn_factor = -1
                            rospy.loginfo('---10---')

                    # Turn timer initiated
                    Turn_time -= 1  
                    Turning_around_right(Turn_factor)
                          
                else:
                    Forward(LINEAR_VEL)
                    Turn_time = 14
                    turtlebot_moving = True
                    rospy.loginfo('---10---')
            
            # Updates the stats
            Accumulated_speed += abs(twist.linear.x)
            Speed_updates += 1
        
            #rospy.on_shutdown(self.Stats)


            

def main():
    rospy.init_node('turtlebot3_obstacle')
    try:
        obstacle = Obstacle()
    except rospy.ROSInterruptException:
        pass

if __name__ == '__main__':
    main()